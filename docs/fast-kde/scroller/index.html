<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, minimum-scale=1.0"
    />
    <title>Fast &amp; Accurate Gaussian Kernel Density Estimation</title>
    <meta property="og:title" content="Fast &amp; Accurate Gaussian Kernel Density Estimation" />
    <meta charset="utf-8" />
    <meta property="og:type" content="article" />

    <link
      rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css"
    />

    <link rel="stylesheet" href="static/idyll_styles.css" />
  </head>
  <body>
    <div id="idyll-mount"><div data-reactroot=""><div class="idyll-root"><div class="article-header" style="background:#ffffff;color:#333333"><h1 class="hed">Fast &amp; Accurate Gaussian Kernel Density Estimation</h1><div class="byline">By: <a target="_blank" href="https://idl.cs.washington.edu" style="color:#333333">Jeffrey Heer</a></div></div><div class=" idyll-text-container"><p>Kernel density estimation (KDE) powers visualizations such as violin plots heat maps and contour plots by modeling a discrete sample as a continuous distribution.</p><img src="static/images/kde-overview.png" alt="kde-overview"/></div><div class="idyll-scroll  " id="idyll-scroll-0" style="position:relative"><div class="idyll-scroll-graphic" style="top:0;left:0;right:0;bottom:auto;width:100%;transform:translate3d(0, 0, 0);z-index:-1;height:0"><div style="width:0;position:absolute;left:0;right:0;top:50%;transform:translateY(-50%)"><div class="idyll-graphic"><div><div><b>Kernel Density Estimation</b></div></div><div><div style="width:100%"></div></div></div></div></div><div class=" idyll-text-container"><div class="idyll-scroll-text"><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      For a set of input data points…
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      …we represent each point with a kernel function.
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      We then sum the kernels to form a continuous density estimate. Here we focus on Gaussian kernels which are commonly used in practice.
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      The spread of the kernels is determined by a bandwidth parameter for Gaussian kernels this is just the standard deviation.
    </p><div class="fidyll-animator" style="display:inline;line-height:1;position:absolute;bottom:5px;right:5px"><svg width="30" height="30" viewBox="0 0 30 30" style="display:block;background:white;cursor:pointer"><defs><clipPath id="cut-off-play-0"><rect x="10" y="0" width="0" height="30"></rect></clipPath></defs><circle cx="15" cy="15" r="15" fill="#ddd"></circle><circle cx="15" cy="15" r="12" fill="white"></circle><path d="M15,0 A15,15 0 0,1 15,0 L15,3 A12,12 0 0,0 15,3 Z" fill="#333"></path><polygon points="10, 7.5 10, 22.5 22.5, 15 " fill="#ddd"></polygon><polygon points="10, 7.5 10, 22.5 22.5, 15 " fill="#333" clip-path="url(#cut-off-play-0)"></polygon></svg></div></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      Unfortunately direct calculation is expensive.
    </p><p scrollOffset="[object Object]" idyll="[object Object]">
      For each of <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">m</span></span></span></span> </span></span> measurement points we must sum the contributions of the <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span> </span></span> data points resulting in quadratic complexity.
    </p><details class="control-details"><summary>
        Controls
      </summary><div><div>
          bandwidth
        </div><input type="range" value="0.025" min="0.01" max="0.5" step="0.01"/></div></details></div></div></div></div><div class="idyll-scroll  " id="idyll-scroll-1" style="position:relative"><div class="idyll-scroll-graphic" style="top:0;left:0;right:0;bottom:auto;width:100%;transform:translate3d(0, 0, 0);z-index:-1;height:0"><div style="width:0;position:absolute;left:0;right:0;top:50%;transform:translateY(-50%)"><div class="idyll-graphic"><div><div><b>Fast &amp; Accurate Approximate KDE?</b></div></div><div><div style="width:100%"></div></div></div></div></div><div class=" idyll-text-container"><div class="idyll-scroll-text"><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      So how might we achieve fast yet accurate approximate estimates? One approach is to discretize the problem by binning the data.
    </p><p scrollOffset="[object Object]" idyll="[object Object]">
      KDE of <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span> </span></span> data points then reduces to a signal processing task smoothing a grid of <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">m</span></span></span></span> </span></span> bins.
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      With simple binning the weight of a data point is assigned to the nearest bin.
    </p><p scrollOffset="[object Object]" idyll="[object Object]">
      If we perturb the points we can see how the weight is reassigned across bin boundaries
    </p><div class="fidyll-animator" style="display:inline;line-height:1;position:absolute;bottom:5px;right:5px"><svg width="30" height="30" viewBox="0 0 30 30" style="display:block;background:white;cursor:pointer"><defs><clipPath id="cut-off-play-1"><rect x="10" y="0" width="0" height="30"></rect></clipPath></defs><circle cx="15" cy="15" r="15" fill="#ddd"></circle><circle cx="15" cy="15" r="12" fill="white"></circle><path d="M15,0 A15,15 0 0,1 15,0 L15,3 A12,12 0 0,0 15,3 Z" fill="#333"></path><polygon points="10, 7.5 10, 22.5 22.5, 15 " fill="#ddd"></polygon><polygon points="10, 7.5 10, 22.5 22.5, 15 " fill="#333" clip-path="url(#cut-off-play-1)"></polygon></svg></div></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      Alternatively we can linearly interpolate weight across bins the weight is assigned proportionally providing some smoothing.
    </p><p scrollOffset="[object Object]" idyll="[object Object]">
      We evaluate both of these binning methods.
    </p><div class="fidyll-animator" style="display:inline;line-height:1;position:absolute;bottom:5px;right:5px"><svg width="30" height="30" viewBox="0 0 30 30" style="display:block;background:white;cursor:pointer"><defs><clipPath id="cut-off-play-2"><rect x="10" y="0" width="0" height="30"></rect></clipPath></defs><circle cx="15" cy="15" r="15" fill="#ddd"></circle><circle cx="15" cy="15" r="12" fill="white"></circle><path d="M15,0 A15,15 0 0,1 15,0 L15,3 A12,12 0 0,0 15,3 Z" fill="#333"></path><polygon points="10, 7.5 10, 22.5 22.5, 15 " fill="#ddd"></polygon><polygon points="10, 7.5 10, 22.5 22.5, 15 " fill="#333" clip-path="url(#cut-off-play-2)"></polygon></svg></div></div></div></div></div><div class="idyll-scroll  " id="idyll-scroll-2" style="position:relative"><div class="idyll-scroll-graphic" style="top:0;left:0;right:0;bottom:auto;width:100%;transform:translate3d(0, 0, 0);z-index:-1;height:0"><div style="width:0;position:absolute;left:0;right:0;top:50%;transform:translateY(-50%)"><div class="idyll-graphic"><div><img data="[object Object]" src="static/images/method-table-01.png" idyll="[object Object]"/></div></div></div></div><div class=" idyll-text-container"><div class="idyll-scroll-text"><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      Now, a number of Gaussian smoothing approaches exist for binned data.
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      We focus on linear time methods that first bin the data, an O(n) step, and then make a bounded number of passes over the binned grid, an O(m) step.
    </p></div></div></div></div><div class="idyll-scroll  " id="idyll-scroll-3" style="position:relative"><div class="idyll-scroll-graphic" style="top:0;left:0;right:0;bottom:auto;width:100%;transform:translate3d(0, 0, 0);z-index:-1;height:0"><div style="width:0;position:absolute;left:0;right:0;top:50%;transform:translateY(-50%)"><div class="idyll-graphic"><div><div><b>Box Filter</b></div><div>Approximate Gaussian filter via iterated uniform filters</div></div><div><img data="[object Object]" src="static/images/box-filter-start.png" title="Box Filter" subtitle="Approximate Gaussian filter via iterated uniform filters" idyll="[object Object]"/></div></div></div></div><div class=" idyll-text-container"><div class="idyll-scroll-text"><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      The first method we’ll consider is box filtering which approximates Gaussian smoothing by iteratively applying a uniform or box filter <a title="Efficient synthesis of Gaussian filters by cascaded uniform filters, William Wells" href="#references">[<!-- -->1<!-- -->]</a>.
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      We sum and scale the input values in the filter window to produce an output bin value.
    </p><div class="fidyll-animator" style="display:inline;line-height:1;position:absolute;bottom:5px;right:5px"><svg width="30" height="30" viewBox="0 0 30 30" style="display:block;background:white;cursor:pointer"><defs><clipPath id="cut-off-play-3"><rect x="10" y="0" width="0" height="30"></rect></clipPath></defs><circle cx="15" cy="15" r="15" fill="#ddd"></circle><circle cx="15" cy="15" r="12" fill="white"></circle><path d="M15,0 A15,15 0 0,1 15,0 L15,3 A12,12 0 0,0 15,3 Z" fill="#333"></path><polygon points="10, 7.5 10, 22.5 22.5, 15 " fill="#ddd"></polygon><polygon points="10, 7.5 10, 22.5 22.5, 15 " fill="#333" clip-path="url(#cut-off-play-3)"></polygon></svg></div></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      We apply this running sum across the input grid writing results into an output grid.
    </p><div class="fidyll-animator" style="display:inline;line-height:1;position:absolute;bottom:5px;right:5px"><svg width="30" height="30" viewBox="0 0 30 30" style="display:block;background:white;cursor:pointer"><defs><clipPath id="cut-off-play-4"><rect x="10" y="0" width="0" height="30"></rect></clipPath></defs><circle cx="15" cy="15" r="15" fill="#ddd"></circle><circle cx="15" cy="15" r="12" fill="white"></circle><path d="M15,0 A15,15 0 0,1 15,0 L15,3 A12,12 0 0,0 15,3 Z" fill="#333"></path><polygon points="10, 7.5 10, 22.5 22.5, 15 " fill="#ddd"></polygon><polygon points="10, 7.5 10, 22.5 22.5, 15 " fill="#333" clip-path="url(#cut-off-play-4)"></polygon></svg></div></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      To perform another iteration we first swap the input and output grids and then apply the box filter again.
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      But note that the box filters can blur weight outside our original grid extent.
    </p><p scrollOffset="[object Object]" idyll="[object Object]">
      Box filter methods require grids with extra padding, which may increase memory use and running time.
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      We perform our second iteration…
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      …swap the grids again perform a third iteration…
    </p><div class="fidyll-animator" style="display:inline;line-height:1;position:absolute;bottom:5px;right:5px"><svg width="30" height="30" viewBox="0 0 30 30" style="display:block;background:white;cursor:pointer"><defs><clipPath id="cut-off-play-5"><rect x="10" y="0" width="0" height="30"></rect></clipPath></defs><circle cx="15" cy="15" r="15" fill="#ddd"></circle><circle cx="15" cy="15" r="12" fill="white"></circle><path d="M15,0 A15,15 0 0,1 15,0 L15,3 A12,12 0 0,0 15,3 Z" fill="#333"></path><polygon points="10, 7.5 10, 22.5 22.5, 15 " fill="#ddd"></polygon><polygon points="10, 7.5 10, 22.5 22.5, 15 " fill="#333" clip-path="url(#cut-off-play-5)"></polygon></svg></div></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      …and arrive at our density estimate.
    </p><p scrollOffset="[object Object]" idyll="[object Object]">
      Box filters are fast and easy to implement but they do have important nuances.
    </p></div></div></div></div><div class="idyll-scroll  " id="idyll-scroll-4" style="position:relative"><div class="idyll-scroll-graphic" style="top:0;left:0;right:0;bottom:auto;width:100%;transform:translate3d(0, 0, 0);z-index:-1;height:0"><div style="width:0;position:absolute;left:0;right:0;top:50%;transform:translateY(-50%)"><div class="idyll-graphic"><div><div><b>Box Filter Quantization Error</b></div></div><div><img data="[object Object]" title="Box Filter Quantization Error" src="static/images/box-filter-quantization-error.png" idyll="[object Object]"/></div></div></div></div><div class=" idyll-text-container"><div class="idyll-scroll-text"><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      We already saw how we must add padding to the grid, but in addition the filter width, which is a function of bandwidth, they can suffer from quantization error.
    </p><p scrollOffset="[object Object]" idyll="[object Object]">
      Here bandwidths of 0.1 and 0.15 both map to a box filter of width 3. The box filter results for the two will be indistinguishable.
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      Similarly here we get a filter width of 5 bins for bandwidths of both 0.2 and 0.25</p></div></div></div></div><div class="idyll-scroll  " id="idyll-scroll-5" style="position:relative"><div class="idyll-scroll-graphic" style="top:0;left:0;right:0;bottom:auto;width:100%;transform:translate3d(0, 0, 0);z-index:-1;height:0"><div style="width:0;position:absolute;left:0;right:0;top:50%;transform:translateY(-50%)"><div class="idyll-graphic"><div><div><b>Extended Box Filter</b></div><div>Gwosdek et al. ‘11</div></div><div><img data="[object Object]" src="static/images/extended-box.png" title="Extended Box Filter" subtitle="Gwosdek et al. ‘11" idyll="[object Object]"/></div></div></div></div><div class=" idyll-text-container"><div class="idyll-scroll-text"><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      To address this, the extended box filter method adds fractional weight to the ends of the filter window<a title="Theoretical foundations of gaussian convolution by extended box filtering, Pascal Gwosdek, Sven Grewenig, Andrés Bruhn, and Joachim Weickert" href="#references">[<!-- -->2<!-- -->]</a>.
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      As the bandwidth varies the extended box varies the filter response more smoothly.
    </p></div></div></div></div><div class="idyll-scroll full-width " id="idyll-scroll-6" style="position:relative"><div class="idyll-scroll-graphic" style="top:0;left:0;right:0;bottom:auto;width:100%;transform:translate3d(0, 0, 0);z-index:-1;height:0"><div style="width:0;position:absolute;left:0;right:0;top:50%;transform:translateY(-50%)"><div class="idyll-graphic"><div><div><b>Deriche&#x27;s Approximation</b></div></div><div><img data="[object Object]" title="Deriche&#x27;s Approximation" src="static/images/deriche_init.png" idyll="[object Object]"/></div></div></div></div><div class=" idyll-text-container"><div class="idyll-scroll-text"><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      Finally let’s consider an approximation developed in the early 90s by Deriche <a title="Recursively implementating the Gaussian and its derivatives, Rachid Deriche" href="#references">[<!-- -->3<!-- -->]</a>, published in the signal processing literature.
    </p><p scrollOffset="[object Object]" idyll="[object Object]">
      This method seems to have been overlooked by statistics and visualization researchers.
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      Deriche derived a recursive filter approximation for the right half of a Gaussian with parameters he determined via optimization.
    </p><p scrollOffset="[object Object]" idyll="[object Object]"><span style="display:block"><span> <span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>K</mi></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mfrac><mrow><mn>1</mn></mrow><mrow><msqrt><mrow><mn>2</mn><mi>π</mi><msup><mi>σ</mi><mn>2</mn></msup></mrow></msqrt></mrow></mfrac><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></munderover><msub><mi>α</mi><mi>k</mi></msub><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi><msub><mi>λ</mi><mi>k</mi></msub><mi mathvariant="normal">/</mi><mi>σ</mi></mrow></msup></mrow><annotation encoding="application/x-tex">h_K(x) = \frac{1}{\sqrt{2 \pi \sigma^2}} \sum_{k=1}^{K} \alpha_k e^{-x \lambda_k / \sigma}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.8283360000000002em;"></span><span class="strut bottom" style="height:3.1304490000000005em;vertical-align:-1.302113em;"></span><span class="base"><span class="mord"><span class="mord mathit">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.154946em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9550540000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span><span class="mord mathit" style="margin-right:0.03588em;">π</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.915054em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.08494599999999997em;"></span></span></span></span></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.2em;"><svg width='400em' height='0.2em' viewBox='0 0 400000 200' preserveAspectRatio='xMinYMin slice'><path d='M0 80H400000 v40H0z M0 80H400000 v40H0z'/></svg></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.07153em;">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"></span></span></span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord"><span class="mord mathit">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathit mtight">x</span><span class="mord mtight"><span class="mord mathit mtight">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathit mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"></span></span></span></span></span><span class="mord mtight">/</span><span class="mord mathit mtight" style="margin-right:0.03588em;">σ</span></span></span></span></span></span></span></span></span></span></span></span></span> </span></span></p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      We can reverse the equation to model the left half of a Gaussian and then sum the two filter responses.
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      The method runs in linear time but does involve more arithmetic operations than box filters.
    </p></div></div></div></div><div class="idyll-scroll  " id="idyll-scroll-7" style="position:relative"><div class="idyll-scroll-graphic" style="top:0;left:0;right:0;bottom:auto;width:100%;transform:translate3d(0, 0, 0);z-index:-1;height:0"><div style="width:0;position:absolute;left:0;right:0;top:50%;transform:translateY(-50%)"><div class="idyll-graphic"><div><img data="[object Object]" src="static/images/evaluate-table.png" idyll="[object Object]"/></div></div></div></div><div class=" idyll-text-container"><div class="idyll-scroll-text"><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      So now let’s evaluate how these linear time methods fare in terms of accuracy.
    </p></div></div></div></div><div class="idyll-scroll full-width " id="idyll-scroll-8" style="position:relative"><div class="idyll-scroll-graphic" style="top:0;left:0;right:0;bottom:auto;width:100%;transform:translate3d(0, 0, 0);z-index:-1;height:0"><div style="width:0;position:absolute;left:0;right:0;top:50%;transform:translateY(-50%)"><div class="idyll-graphic"><div><div><b>Impulse Test</b></div></div><div><img data="[object Object]" src="static/images/impulse-intro-00.png" title="Impulse Test" idyll="[object Object]"/></div></div></div></div><div class=" idyll-text-container"><div class="idyll-scroll-text"><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      We’ll start with an impulse test involving a single data point, corresponding to a single Gaussian density.
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      We can compare direct calculation with box filters…
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      …and extended box filters.
    </p><p scrollOffset="[object Object]" idyll="[object Object]">
      We see that both methods lead to underestimation of the peak and poor fit to the tails of the distribution.
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      Meanwhile, the Deriche method achieves high accuracy.
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      We must also inspect other bandwidth values…
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      …to more systematically measure the error.
    </p></div></div></div></div><div class="idyll-scroll  " id="idyll-scroll-9" style="position:relative"><div class="idyll-scroll-graphic" style="top:0;left:0;right:0;bottom:auto;width:100%;transform:translate3d(0, 0, 0);z-index:-1;height:0"><div style="width:0;position:absolute;left:0;right:0;top:50%;transform:translateY(-50%)"><div class="idyll-graphic"><div><div><b>Measuring Error</b></div></div><div><div style="width:100%"></div></div></div></div></div><div class=" idyll-text-container"><div class="idyll-scroll-text"><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      For each KDE method we measure the maximum pixel error for a 100 pixel tall density chart, plotting the results on a logarithmic scale.
    </p><p scrollOffset="[object Object]" idyll="[object Object]">
      We do this across a range of bandwidths.
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      Here are the error curves for simple binning on a 256 bin grid. We see oscillation in the box method due to filter quantization. The extended box method smooths this out.
    </p><p scrollOffset="[object Object]" idyll="[object Object]">
      Deriche’s method outperforms the others and, at high bandwidth, it’s over an order of magnitude better with a maximum error around one pixel.
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      Switching to linear binning the Deriche method improves with subpixel accuracy for most tested bandwidths
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      If we double the number of bins Deriche improves further to near pixel perfect accuracy almost two orders of magnitude better than box filter methods.
    </p><details class="control-details"><summary>
        Controls
      </summary><div><div>
          bins
        </div><select options="[object Object],[object Object]"><option selected="" value="256">256</option><option value="512">512</option></select></div><div><div>
          binMethod
        </div><select options="[object Object],[object Object]"><option selected="" value="Simple Binning">Simple Binning</option><option value="Linear Binning">Linear Binning</option></select></div></details></div></div></div></div><div class="idyll-scroll full-width " id="idyll-scroll-10" style="position:relative"><div class="idyll-scroll-graphic" style="top:0;left:0;right:0;bottom:auto;width:100%;transform:translate3d(0, 0, 0);z-index:-1;height:0"><div style="width:0;position:absolute;left:0;right:0;top:50%;transform:translateY(-50%)"><div class="idyll-graphic"><div><div><b>Palmer Penguins</b></div></div><div><img data="[object Object]" src="static/images/penguins-00.png" title="Palmer Penguins" idyll="[object Object]"/></div></div></div></div><div class=" idyll-text-container"><div class="idyll-scroll-text"><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      Ultimately we care about real world data, so here’s an excerpt from the Palmer penguins data set showing an estimated density of penguin body mass.
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      At bandwidth 200, all methods appear to perform reasonably well.
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      However at lower bandwidths we see some significant discrepancies.
    </p><p scrollOffset="[object Object]" idyll="[object Object]">
      The box filter methods may misestimate peaks or erode local optima and in the language of algebraic vis these are hallucinators that is our choice of technique may mislead us with inaccurate visual features <a title="An algebraic process for visualization design, Gordon Kindlmann and Carlos Scheidegger" href="#references">[<!-- -->4<!-- -->]</a>.
    </p></div></div></div></div><div class="idyll-scroll  " id="idyll-scroll-11" style="position:relative"><div class="idyll-scroll-graphic" style="top:0;left:0;right:0;bottom:auto;width:100%;transform:translate3d(0, 0, 0);z-index:-1;height:0"><div style="width:0;position:absolute;left:0;right:0;top:50%;transform:translateY(-50%)"><div class="idyll-graphic"><div><div><b>Error - Simple binning, 256 bins</b></div></div><div><div style="width:100%"></div></div></div></div></div><div class=" idyll-text-container"><div class="idyll-scroll-text"><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      Looking across bandwidths, here are the results for simple binning with 256 bins. Again the Deriche method provides the best performance.
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      Accuracy improves with linear binning…
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      and the performance gap widens when doubling the number of bins.
    </p><details class="control-details"><summary>
        Controls
      </summary><div><div>
          bins
        </div><select options="[object Object],[object Object]"><option selected="" value="256">256</option><option value="512">512</option></select></div><div><div>
          binMethod
        </div><select options="[object Object],[object Object]"><option selected="" value="Simple Binning">Simple Binning</option><option value="Linear Binning">Linear Binning</option></select></div></details></div></div></div></div><div class="idyll-scroll  " id="idyll-scroll-12" style="position:relative"><div class="idyll-scroll-graphic" style="top:0;left:0;right:0;bottom:auto;width:100%;transform:translate3d(0, 0, 0);z-index:-1;height:0"><div style="width:0;position:absolute;left:0;right:0;top:50%;transform:translateY(-50%)"><div class="idyll-graphic"><div><div><b>2D Density Estimation</b></div></div><div><img data="[object Object]" src="static/images/density-estimation-text.png" title="2D Density Estimation" idyll="[object Object]"/></div></div></div></div><div class=" idyll-text-container"><div class="idyll-scroll-text"><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      So finally let’s examine 2d density estimation for heat maps and contour plots we’ll look at mileage versus horsepower in the classic cars data set.
    </p></div></div></div></div><div class="idyll-scroll  " id="idyll-scroll-13" style="position:relative"><div class="idyll-scroll-graphic" style="top:0;left:0;right:0;bottom:auto;width:100%;transform:translate3d(0, 0, 0);z-index:-1;height:0"><div style="width:0;position:absolute;left:0;right:0;top:50%;transform:translateY(-50%)"><div class="idyll-graphic"><div><img data="[object Object]" src="static/images/2d-density-01.png" idyll="[object Object]"/></div></div></div></div><div class=" idyll-text-container"><div class="idyll-scroll-text"><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      Using direct calculation as a baseline we can visualize the difference in estimates when using box and extended box filtering.
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      We again see that these methods tend to underestimate peaks yet overestimate the size of a distribution.
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      Errors from the Deriche method however are imperceptibly low on this color scale.
    </p></div></div></div></div><div class="idyll-scroll full-width " id="idyll-scroll-14" style="position:relative"><div class="idyll-scroll-graphic" style="top:0;left:0;right:0;bottom:auto;width:100%;transform:translate3d(0, 0, 0);z-index:-1;height:0"><div style="width:0;position:absolute;left:0;right:0;top:50%;transform:translateY(-50%)"><div class="idyll-graphic"><div><img data="[object Object]" src="static/images/2d-density-04.png" idyll="[object Object]"/></div></div></div></div><div class=" idyll-text-container"><div class="idyll-scroll-text"><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      Now if we overlay contours from all three methods we’ll find that Deriche matches the ground truth…
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      …while the box filter methods can incur missing contours missed estimated peaks and again other hallucinators.
    </p></div></div></div></div><div class="idyll-scroll  " id="idyll-scroll-15" style="position:relative"><div class="idyll-scroll-graphic" style="top:0;left:0;right:0;bottom:auto;width:100%;transform:translate3d(0, 0, 0);z-index:-1;height:0"><div style="width:0;position:absolute;left:0;right:0;top:50%;transform:translateY(-50%)"><div class="idyll-graphic"><div><div><b>Error - Simple binning, 256 x 256 bins</b></div></div><div><div style="width:100%"></div></div></div></div></div><div class=" idyll-text-container"><div class="idyll-scroll-text"><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      Across bandwidths we see that the Deriche method is consistently better.
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      Once again this further improves by using linear binning…
    </p></div><div class="idyll-step "><p scrollOffset="[object Object]" idyll="[object Object]">
      …and increasing the grid size.
    </p><details class="control-details"><summary>
        Controls
      </summary><div><div>
          bins
        </div><select options="[object Object],[object Object]"><option selected="" value="256">256</option><option value="512">512</option></select></div><div><div>
          binMethod
        </div><select options="[object Object],[object Object]"><option selected="" value="Simple Binning">Simple Binning</option><option value="Linear Binning">Linear Binning</option></select></div></details></div></div></div></div><div class=" idyll-text-container"><p>In conclusion, we find that the combination of Deriche’s approximation in linear binning provides high accuracy with a competitive linear running time. We recommend its use for one and two dimensional density visualizations.</p><p>There are some important limitations the method only supports Gaussian kernels not other forms of kernel functions and it’s inherently a one-dimensional technique that is use across multiple dimensions requires separable independent axes.</p><div id="references"><h1>References</h1><ol><li><a target="_blank">Efficient synthesis of Gaussian filters by cascaded uniform filters</a>, <!-- -->William Wells<!-- -->.<em> IEEE Transactions on Pattern Analysis and Machine Intelligence.</em> 1993.</li><li><a target="_blank">Theoretical foundations of gaussian convolution by extended box filtering</a>, <!-- -->Pascal Gwosdek, Sven Grewenig, Andrés Bruhn, and Joachim Weickert<!-- -->.<em> IEEE Transactions on Pattern Analysis and Machine Intelligence.</em> 1993.</li><li><a target="_blank">Recursively implementating the Gaussian and its derivatives</a>, <!-- -->Rachid Deriche<!-- -->.<em> INRIA.</em> 1993.</li><li><a target="_blank">An algebraic process for visualization design</a>, <!-- -->Gordon Kindlmann and Carlos Scheidegger<!-- -->.<em> IEEE transactions on visualization and computer graphics.</em> 2014.</li></ol></div></div></div></div></div>
    <script src="static/idyll_index.js"></script>
  </body>
</html>
